==========================================
Sunday, November 12, 2017
==========================================

I think I'll try keeping a little journal of my adventures making this, that may
help me make a blog entry or two after I get sideauth working (at least minimally).

I'm still trying to clean up the code I extracted into the sideauth project from
funtodone, and rename things, reorganize things, etc. Fortunately, since this is
no longer just a bit of another project, I can take my time with this and use TDD,
and see what kind of best practices I can learn while doing it.

The first thing I'm working on is a POST to create a new account. I want to eventually
add support for OAuth2, but for now I just want to get regular accounts with passwords
implemented, with password reset done via email and account creation verified by 
email. I'll need to add APIs for reset and account verification.

Testing resources:
https://golang.org/pkg/net/http/httptest/
https://elithrar.github.io/article/testing-http-handlers-go/
https://medium.com/@PurdonKyle/unit-testing-golang-http-middleware-c7727ca896ea

I've got some code in session_persist.go that should be helpful in figuring out the
account stuff for mongo interactions.

==========================================
Thursday, November 30, 2017
==========================================
My little "random project picker" says that tonight I should work on sideauth coding.

(Unfortunately, it's already late and I'm unbelievably tired.)

I think I'll work on a test for POST to /accounts next, which will call CreateAccount
in the authapi.go file. Actually, I think I'll rename some things, and call that file "account.go"
and rename some of the stuff inside it.


==========================================
Saturday, December 2, 2017
==========================================

I think the main problem with this is that it's a hodgepodge of stuff that I copied
and pasted from github, along with stuff I made for another project, done in a way
that doesn't really match what anyone needs.

For example, the session stuff might be useful for a website, but it's not really
something that a web site needs. You need a session ID, and to have session associated
with a valid account, but all the memory/state for a session can be easily done by
the website without tying it in to an auth/session service. Or at least, that's what
it seems to me tonight.

Next steps are to pare this down to the essentials.


==========================================
Monday, December 4, 2017
==========================================

I suppose a way to add value for anyone using sideauth could be to have "sessions"
that span devices or browsers. I know some sites keep track of which devices you're
logged in on, and will ask you if you want to log out of one you're not currently
using. (This often ties in to some kind of DRM, but it doesn't need to.)

That gets close to developing some sort of single-sign-on though, and seems like
it could get super hairy. The advantage of putting all your session data in a cookie 
is that you can scale up your web app without needing a database behind the sessions.

In any case, most people don't need that, at least not right away. What they need 
is a way to let people create an account, recover a lost password (if they use one),
and verify the credentials. The web app that uses sideauth can then do whatever 
it wants on a successful login.

Since I personally get very annoyed when people allow account creation without email
verification, I won't even have an option to not do that with sideauth.

So the flow will be:

For Account creation
  1) get an account ID, an email address, and a pwhash (we'll do OAuth2 later)
  2) verify the account ID doesn't already exist, error if it does 
  3) create the account, status unverified, send email to the email address
  4) later, when someone clicks on the link, mark account as verified
For Login:
  1) get an account ID and a pwhash 
  2) if the account doesn't exist, or is unverified, or the pwhash doesn't match, fail the login 
  3) send back success and some metadata (maybe) like time of last successful login, number of failed logins
For Password Reset:
  1) get an account ID 
  2) send email to associated email
  3) wait for POST to reset form

There needs to be a set of admin operations too (delete an account, lock an account, change email, ...)
There needs to be a way to change email if you have the right credentials

==========================================
Thursday, December 21, 2017
==========================================

What I didn't explicitly say last time was that I wouldn't be doing sessions,
or at least I left it a little ambiguous. No sessions.

The pwhash: I don't care what algorithm is used (MD5 or SHA256, etc) or what
salt is used, since sideauth will only ever see the hashed value. 

Admin operations should (eventually) use a different API key.
All operations should be authorized (eventually) between the 
calling service and sideauth, presumably via JWT or something.

I want to eventually support a tenanted solution with a separate
name space for different tenants for accounts. For the first cut,
I'll just pass in a default tenant ID.

Sideauth should be deployed as a separate docker container along
with the service that is using it. It would be best practice to
use a firewall to prevent API calls from elsewhere, but having
a unique API key will be enough to get started.

==========================================
Friday, December 22, 2017
==========================================

I have a cold and fever today, so I don't trust myself to try
anything but documentation. I updated the apis.txt file will more
details about how account verification and password reset might
work. I need to think about that some more, though.

==========================================
Monday, December 25, 2017
==========================================

Let's do some TDD today!

I changed "ping" to status and added return values for:
  a) database status
  b) uptime
  c) duration of the status API call
  d) service version

==========================================
Friday, January 5, 2018
==========================================

Wanted to do a little more testing today, but ran out of 
time. Just made a stub for account testing.

==========================================
Tuesday, January 16, 2018
==========================================

OK! Let's go. I have 20 entire minutes!

Account creation. Let's pseudocode:

1) handle an API call, and get the values
  a) account name
  b) pwhash
  c) email address
2) verify that the account doesn't already exist
  a) look up the account in the database
3) verify that the email address is real and belongs to the end user

There are verification steps for each of the above as well:
1) verify that the account name is non-empty and UTF-8
  a) look up account, if it exists already return an error
2) verify that the pwhash is non-empty and UTF-8
  a) return an error if it is not
3) verify that the email address looks like an email address
  a) return an error if it doesn't
4) send email to the email address with a link to click
  a) when link is clicked, mark the email address as verified
  b) until it's verified, queries for the account should say it's unverified

To look up account:
1) open a connection to the database when the service is started
2) verify that the account is UTF-8
3) query the database for the account
4) if found, return an error
5) periodically clean the database of unused accounts
6) prevent accounts that look like hacks (sql injection, cross site scripting)
7) log the query

==========================================
Wednesday, January 17, 2018
==========================================

Started adding a test for Account creation.
Still a lot more to do in it, though.

==========================================
Saturday, February 10, 2018
==========================================

Tonight's randomly selected task is design of sideauth.

Let's just focus on overall service stuff.
1) run the service
2) log a fatal error if the port is unavailable
3) create rest endpoints

I started by just clicking the "debug test" link
on account_test.go in vscode, and got:
could not launch process: dial tcp :53450: getsockopt: connection refused

Following a rumor on the vscode site, I'm trying to upgrade delve:

brew unlink delve && brew install go-delve/delve/delve --HEAD

That updated it from Version: 1.0.0-rc.1 to Version: 1.0.0-rc.2

That got past that problem! Now I just need to figure out
how to pass in an account struct to http.NewRequest

==========================================
Sunday, February 11, 2018
==========================================

I figured out how to pass in arguments to the NewRequest POST.
Now I just need to implement the code being tested!


==========================================
Saturday, February 17, 2018
==========================================

Today's randomly selected project/focus is: sideauth/design

The goal of sideauth is to be able to just drop in a small service
running in a container, configure a small database (mongodb), and
wire it up to your project to provide a super easy solution to
a problem that prevents people from just exposing whatever they're
actually working on to the harsh environment of the open internet.

Here's the flow I hope will work for most people:

1) user opens web site
2) web site checks for a valid session cookie
  a) if there is a valid session cookie, show all the things they are allowed to do
  b) session cookie should encode the account, to check authorization/permissions/etc.
  c) if there is no session cookie, or it's not valid (expired or something), go to 3)
3) show things that you don't need to be logged in to see, including links to log in or sign up
4) log in form takes (at minimum) an account name and password
  a) should provide for OAuth2 and MFA eventually, but worry about that later
  b) should have a "forgot my password" option, in which case go to 5)
  c) should have a "forgot my account" option, in which case go to 6)
  d) checking the password involves calling sideauth, and generating a valid session cookie upon success
5) a "forgot my password" form should send email to the email associated with an account
  a) include a link to click that says "reset my password" that expires in a short time
  b) if they click the link, open a page with a form to reset the password
  c) call sideauth with the password reset data 
6) a "forgot my account" form should ask for email, and send email to that account
  a) email should have the account code to use
  b) if email isn't in database, just have the form say so

The forms should be on the domain of the user. Recommended way of handling those 
links is to proxy links through nginx to sideauth, with URLs something like:

https://mydomain.com/auth/forgot/account/{GUID}
https://mydomain.com/auth/forgot/password/{GUID}

Where GUID is generated by sideauth and is verified.

The login/signup form should be done in the app itself, and just call sideauth APIs.
The "forgot my..." forms should be done in sideauth using templates belonging to the app
The email messages should be sent by sideauth using templates belonging to the app

At this point I want to take a step back and see if there's a way
to use something that already exists, and maybe do more documentation
than code.

If I were to use a docker container with a Rack server running OmniAuth, for 
example (https://github.com/omniauth/omniauth), and configure the callback on 
session creation to call an endpoint in the app itself, and *if* (a big if)
I could turn that session data into a session structure that the app itself
can handle from then on, then perhaps it would work.

My big concern is that while login/signup can use less scalable technology,
the operations that happen after successful login should not need to go
through a Rack (or RAILS) server before getting to whatever the app is
written in.

Maybe I should try out something like a simple RAILS service using Devise 
(which uses OmniAuth) which then posts the session to an app endpoint on
login? That handles sending email as well. On the other hand, that's likely 
to be hard to configure simply, so the poor sideauth user would have to 
learn RAILS (and be prepared to support it) to do the simplest auth.

No, the more I think about it, I think my initial instinct was correct.

Do the simplest thing I can, to just support password login with recovery,
and if someone wants to use more sophisticated auth they're better off
getting a professional-strength solution and doing it right.

==========================================
Tuesday, February 20, 2018
==========================================

Today's randomly selected project/focus is: sideauth/test

The problem is, I've forgotten everything I've ever learned about MongoDB,
including how I installed it on my macbook pro and what the schema looks
like. I can tell it's running, though, based on ps:

ps aux | grep mongo
ron                444   0.1  0.1  5078336  21848   ??  S    Thu05PM  16:57.45 /usr/local/opt/mongodb/bin/mongod --config /usr/local/etc/mongod.conf

When I type "mongo" and then "db.help()" I see a bunch of things I can try.

> db.getCollectionNames()
[ "sessions", "tasks" ]

> db.getName()
test

> show dbs
local        0.000GB
test         0.000GB
twitterbots  0.000GB

I guess tasks must be from funtodone? Session may be from there, or from sideauth.

Let's make a database with an accounts collection!

> use sideauth
switched to db sideauth
> db
sideauth
> show dbs
local        0.000GB
test         0.000GB
twitterbots  0.000GB
> db.account.insert({"name":"test"})
WriteResult({ "nInserted" : 1 })
> show dbs
local        0.000GB
sideauth     0.000GB
test         0.000GB
twitterbots  0.000GB
>

Neat! Now I have a db named "sideauth" with a collection named "account":
> db.getCollectionNames()
[ "account" ]

I should have named it "accounts" I think?
> db.account.drop()
true
> db.getCollectionNames()
[ ]

Let's drop the databases I don't remember?
> use twitterbots
> db.dropDatabase()
{ "dropped" : "twitterbots", "ok" : 1 }
> show dbs
local     0.000GB
sideauth  0.000GB
test      0.000GB
> use test
switched to db test
> db.dropDatabase()

> use sideauth
switched to db sideauth
> db.getCollectionNames()
[ "accounts" ]

OK! 

==========================================
Sunday, February 25, 2018
==========================================

Oh boy. I don't remember much about what I was doing with this project,
and it's been about a week.

Also, it's already late.

First thing: look through what I've done lately...

OK. Big points:

1) This is to manage auth, not sessions
2) So the main thing is to figure out what's in auth, and what's in sessions
3) Maybe I should start with a sample app? The old "begin with the end in mind" thing?

OK. That sounds good. What's a good app?

How about thingaday? Should be hard, but less hard than most things.

==========================================
Monday, February 26, 2018
==========================================

First Step: create an account for thingaday

* sideauth will have sample template for account creation
* thingaday will use customized version
* post to thingaday REST endpoint will be proxied to sideauth
* sideauth will return status 200 if account is created successfully
* thingaday rest handler will redirect to a "look for your email" page

* email will be html email with GET link to thingaday URL
* rest handler for thingaday will POST URL secret to sideauth
* sideauth marks account valid and returns 200
* thingaday creates session and redirects to landing page
