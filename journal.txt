==========================================
Sunday, November 12, 2017
==========================================

I think I'll try keeping a little journal of my adventures making this, that may
help me make a blog entry or two after I get sideauth working (at least minimally).

I'm still trying to clean up the code I extracted into the sideauth project from
funtodone, and rename things, reorganize things, etc. Fortunately, since this is
no longer just a bit of another project, I can take my time with this and use TDD,
and see what kind of best practices I can learn while doing it.

The first thing I'm working on is a POST to create a new account. I want to eventually
add support for OAuth2, but for now I just want to get regular accounts with passwords
implemented, with password reset done via email and account creation verified by 
email. I'll need to add APIs for reset and account verification.

Testing resources:
https://golang.org/pkg/net/http/httptest/
https://elithrar.github.io/article/testing-http-handlers-go/
https://medium.com/@PurdonKyle/unit-testing-golang-http-middleware-c7727ca896ea

I've got some code in session_persist.go that should be helpful in figuring out the
account stuff for mongo interactions.

==========================================
Thursday, November 30, 2017
==========================================
My little "random project picker" says that tonight I should work on sideauth coding.

(Unfortunately, it's already late and I'm unbelievably tired.)

I think I'll work on a test for POST to /accounts next, which will call CreateAccount
in the authapi.go file. Actually, I think I'll rename some things, and call that file "account.go"
and rename some of the stuff inside it.


==========================================
Saturday, December 2, 2017
==========================================

I think the main problem with this is that it's a hodgepodge of stuff that I copied
and pasted from github, along with stuff I made for another project, done in a way
that doesn't really match what anyone needs.

For example, the session stuff might be useful for a website, but it's not really
something that a web site needs. You need a session ID, and to have session associated
with a valid account, but all the memory/state for a session can be easily done by
the website without tying it in to an auth/session service. Or at least, that's what
it seems to me tonight.

Next steps are to pare this down to the essentials.


==========================================
Monday, December 4, 2017
==========================================

I suppose a way to add value for anyone using sideauth could be to have "sessions"
that span devices or browsers. I know some sites keep track of which devices you're
logged in on, and will ask you if you want to log out of one you're not currently
using. (This often ties in to some kind of DRM, but it doesn't need to.)

That gets close to developing some sort of single-sign-on though, and seems like
it could get super hairy. The advantage of putting all your session data in a cookie 
is that you can scale up your web app without needing a database behind the sessions.

In any case, most people don't need that, at least not right away. What they need 
is a way to let people create an account, recover a lost password (if they use one),
and verify the credentials. The web app that uses sideauth can then do whatever 
it wants on a successful login.

Since I personally get very annoyed when people allow account creation without email
verification, I won't even have an option to not do that with sideauth.

So the flow will be:

For Account creation
  1) get an account ID, an email address, and a pwhash (we'll do OAuth2 later)
  2) verify the account ID doesn't already exist, error if it does 
  3) create the account, status unverified, send email to the email address
  4) later, when someone clicks on the link, mark account as verified
For Login:
  1) get an account ID and a pwhash 
  2) if the account doesn't exist, or is unverified, or the pwhash doesn't match, fail the login 
  3) send back success and some metadata (maybe) like time of last successful login, number of failed logins
For Password Reset:
  1) get an account ID 
  2) send email to associated email
  3) wait for POST to reset form

There needs to be a set of admin operations too (delete an account, lock an account, change email, ...)
There needs to be a way to change email if you have the right credentials

==========================================
Thursday, December 21, 2017
==========================================

What I didn't explicitly say last time was that I wouldn't be doing sessions,
or at least I left it a little ambiguous. No sessions.

The pwhash: I don't care what algorithm is used (MD5 or SHA256, etc) or what
salt is used, since sideauth will only ever see the hashed value. 

Admin operations should (eventually) use a different API key.
All operations should be authorized (eventually) between the 
calling service and sideauth, presumably via JWT or something.

I want to eventually support a tenanted solution with a separate
name space for different tenants for accounts. For the first cut,
I'll just pass in a default tenant ID.

Sideauth should be deployed as a separate docker container along
with the service that is using it. It would be best practice to
use a firewall to prevent API calls from elsewhere, but having
a unique API key will be enough to get started.

==========================================
Friday, December 22, 2017
==========================================

I have a cold and fever today, so I don't trust myself to try
anything but documentation. I updated the apis.txt file will more
details about how account verification and password reset might
work. I need to think about that some more, though.

==========================================
Monday, December 25, 2017
==========================================

Let's do some TDD today!

I changed "ping" to status and added return values for:
  a) database status
  b) uptime
  c) duration of the status API call
  d) service version

==========================================
Friday, January 5, 2018
==========================================

Wanted to do a little more testing today, but ran out of 
time. Just made a stub for account testing.

==========================================
Tuesday, January 16, 2018
==========================================

OK! Let's go. I have 20 entire minutes!

Account creation. Let's pseudocode:

1) handle an API call, and get the values
  a) account name
  b) pwhash
  c) email address
2) verify that the account doesn't already exist
  a) look up the account in the database
3) verify that the email address is real and belongs to the end user

There are verification steps for each of the above as well:
1) verify that the account name is non-empty and UTF-8
  a) look up account, if it exists already return an error
2) verify that the pwhash is non-empty and UTF-8
  a) return an error if it is not
3) verify that the email address looks like an email address
  a) return an error if it doesn't
4) send email to the email address with a link to click
  a) when link is clicked, mark the email address as verified
  b) until it's verified, queries for the account should say it's unverified

To look up account:
1) open a connection to the database when the service is started
2) verify that the account is UTF-8
3) query the database for the account
4) if found, return an error
5) periodically clean the database of unused accounts
6) prevent accounts that look like hacks (sql injection, cross site scripting)
7) log the query

==========================================
Wednesday, January 17, 2018
==========================================

Started adding a test for Account creation.
Still a lot more to do in it, though.

==========================================
Saturday, February 10, 2018
==========================================

Tonight's randomly selected task is design of sideauth.

Let's just focus on overall service stuff.
1) run the service
2) log a fatal error if the port is unavailable
3) create rest endpoints

I started by just clicking the "debug test" link
on account_test.go in vscode, and got:
could not launch process: dial tcp :53450: getsockopt: connection refused

Following a rumor on the vscode site, I'm trying to upgrade delve:

brew unlink delve && brew install go-delve/delve/delve --HEAD

That updated it from Version: 1.0.0-rc.1 to Version: 1.0.0-rc.2

That got past that problem! Now I just need to figure out
how to pass in an account struct to http.NewRequest


